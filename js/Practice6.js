//React
/*
React is a JavaScript library for building user interfaces. It is maintained by Facebook and a community of individual developers and companies. React can be used as a base in the development of single-page or mobile applications.

Key Elements of React:

Components: React applications are made up of components, which are reusable and independent pieces of code that represent a part of the user interface. Components can be class components or functional components. Components accept inputs called props and return React elements that describe how a section of the UI should appear.

JSX: JSX is a syntax extension for JavaScript that allows you to write HTML-like code within your JavaScript files. It is used to describe what the UI should look like and is transformed into regular JavaScript function calls by Babel.

Virtual DOM: React uses a virtual DOM to improve performance by updating the DOM only when necessary. When the state of a component changes, React creates a new virtual DOM tree and compares it with the previous one to determine the minimal number of changes needed to update the actual DOM.

State: State is a built-in feature of React components that allows them to store and manage their own data. When the state of a component changes, React re-renders the component to reflect the updated state.

Props: Props (short for properties) are inputs that are passed to a component from its parent component. Props are read-only and help to make components reusable and customizable. React rerenders a component when its props change.

Lifecycle Methods: React components have lifecycle methods that allow you to run code at specific points in a component's life cycle, such as when it is mounted or updated. Some common lifecycle methods include componentDidMount, componentDidUpdate, and componentWillUnmount. In case of functional components, React introduced hooks to handle lifecycle methods like useEffect;

React Hooks: React Hooks are functions that allow you to use state and other React features in functional components. They were introduced in React 16.8 to provide a simpler way to manage state and side effects in functional components.



What is the Virtual DOM?

The Virtual DOM (VDOM) is an in-memory representation of the real DOM elements generated by React components. It's a lightweight copy of the actual DOM that React uses to efficiently update the UI.


How does the Virtual DOM work?

Initial Render:
When a React component is first rendered, React creates a Virtual DOM tree that mirrors the structure of the actual DOM.

Updates:
When the state or props of a component change, React updates the Virtual DOM instead of the real DOM immediately.
React creates a new Virtual DOM tree to reflect the changes.

Diffing Algorithm:
React uses a reconciliation process to compare the new Virtual DOM tree with the previous one. This process is known as the "diffing algorithm."
The algorithm identifies the differences (or deltas) between the two Virtual DOM trees.

Patch:
After identifying the differences, React calculates the minimal set of changes required to update the real DOM to match the new Virtual DOM.
React then applies these changes (patches) to the real DOM in a batch process, minimizing direct DOM manipulations and improving performance.

const virtualDOM = {
  type: 'div',
  props: {
    className: 'container',
    children: [
      {
        type: 'h1',
        props: {
          children: 'Hello, World!'
        }
      },
      {
        type: 'p',
        props: {
          children: 'This is a paragraph.'
        }
      }
    ]
  }
};

Explain the process of reconciliation in React?
Reconciliation is the process React uses to compare the new Virtual DOM with the previous one and update the real DOM efficiently. It involves diffing the two Virtual DOM trees and applying the minimal changes to the real DOM.

Why is manipulating the real DOM directly considered slow?
Manipulating the real DOM directly is slow because it triggers reflows and repaints, which are computationally expensive operations. The real DOM is also synchronous, meaning updates can block rendering and degrade performance.

How does the diffing algorithm work in React?
The diffing algorithm compares the new Virtual DOM tree with the old one node by node. It identifies the differences and generates a patch to update the real DOM with the minimal set of changes.

What are some optimizations React employs when using the Virtual DOM?
React batches DOM updates to minimize reflows and repaints.
It uses keys to optimize the reconciliation process, especially for lists of elements.
It performs updates asynchronously to avoid blocking the main thread.

When react component re-renders?
| Trigger                       | Description                                                                                  |
|-------------------------------|----------------------------------------------------------------------------------------------|
| State Changes                 | Re-renders when the component's state is updated.                                            |
| Prop Changes                  | Re-renders when the component receives new props from its parent.                            |
| Context Changes               | Re-renders when the context value changes and the component consumes that context.           |
| Parent Component Re-renders   | Re-renders when the parent component re-renders, affecting all child components.             |
| Force Update                  | Re-renders when `forceUpdate` is called on a class component.                                |
--------------------------------------------------------------------------------------------------------------------------------

*/

/*
Functional Components vs. Class Components in React
--------------------------------------------------------------------------------------------------------------------
| Feature                  | Functional Components                    | Class Components                           |
|--------------------------|------------------------------------------|--------------------------------------------|
| Syntax                   | Function-based                           | Class-based                                |
| State Management         | useState and useReducer hooks            | this.state and this.setState               |
| Lifecycle Methods        | useEffect hook                           | Component lifecycle methods                |
| Simplicity               | More concise, less boilerplate           | More verbose, more boilerplate             |
| Performance              | Generally faster, fewer overheads        | Slightly slower due to additional methods  |
| Side Effects             | useEffect hook for side effects          | Lifecycle methods for side effects         |
| Ref Handling             | useRef hook                              | React.createRef()                          |
| Context API              | useContext hook                          | Context.Consumer and Context.Provider      |
| Hooks                    | Can use hooks                            | Cannot use hooks                           |
| State Initialization     | Inside the function                      | Inside the constructor                     |
| Higher-Order Components  | Easier to compose with hooks             | Can be composed but with more boilerplate  |
| This Keyword             | Not needed                               | Needed to access props and state           |
| Props                    | Passed as arguments                      | Accessed via this.props                    |
| Default Props            | Not supported                            | Supported                                  |
--------------------------------------------------------------------------------------------------------------------
*/

/*
Component Lifecycle of React Functional Components:
In React functional components, the lifecycle is managed using the useEffect Hook. The useEffect Hook allows you to perform side effects in your function components, and it can mimic the behavior of lifecycle methods found in class components


Lifecycle Phases in Functional Components:
1. Mounting
Equivalent to componentDidMount in Class Components:
To run an effect once when the component mounts, you use an empty dependency array ([]). This means the effect will run only once, after the initial render.

2. Updating
Equivalent to componentDidUpdate in Class Components:
To run an effect after every render or when specific dependencies change, include those dependencies in the dependency array.

3. Unmounting
Equivalent to componentWillUnmount in Class Components:
To run cleanup logic when the component unmounts, return a cleanup function from the useEffect Hook. This cleanup function will also run before the component re-renders if dependencies change.
*/

/*
State vs Props in React:

| Feature    | State                      | Props                                      |
|------------|----------------------------|--------------------------------------------|
| Definition | Managed within the component | Passed from parent to child                 |
| Mutability | Mutable                    | Immutable                                  |
| Scope      | Local to the component     | Passed down the component tree              |
| Management | Managed using useState Hook | Passed as attributes in JSX                 |
| Purpose    | For dynamic data           | For passing data and functions to children  |

What happens if you try to modify props directly?
Props are read-only and cannot be modified. Attempting to change props directly will not work and can lead to unexpected behavior or errors.
*/

/*
Compilation of React Code
Babel is used to transform JSX into JavaScript and to transpile modern JavaScript (ES6+) into a version that is compatible with older browsers (ES5). Webpack is a module bundler that is used to bundle JavaScript files and other assets for the web.


Steps in the Compilation Process:

JSX to JavaScript Transformation:
React code often contains JSX, a syntax extension that allows writing HTML-like code within JavaScript.
Browsers do not understand JSX directly, so it needs to be transformed into plain JavaScript.
Babel, a JavaScript compiler, is commonly used to transform JSX into JavaScript.
const element = <h1>Hello, world!</h1>; // JSX
const element = React.createElement('h1', null, 'Hello, world!'); // Transformed JavaScript by Babel

ES6+ Syntax Transformation:
Modern JavaScript (ES6 and beyond) includes features like arrow functions, classes, template literals, and more.
Not all browsers support these features, so Babel is also used to transpile modern JavaScript into a version compatible with older browsers (usually ES5).

Bundling:
React applications often consist of multiple modules and files.
A bundler like Webpack or Parcel is used to bundle all these modules into a single file (or a few files) that can be included in a web page.
The bundler also handles other assets like CSS, images, etc
*/

/*
React Hooks:
-----------

1. useEffect:

The useEffect Hook is used to perform side effects in functional components. It replaces lifecycle methods like componentDidMount, componentDidUpdate, and componentWillUnmount in class components.

useEffect(() => {
  // Side-effect logic here
  return () => {
    // Cleanup logic here
  };
}, [dependencies]);

Cleanup Function:
The cleanup function returned from the useEffect Hook is used to perform cleanup tasks when the component unmounts or before it re-renders due to changes in dependencies that are specified in the dependency array.

Passing an empty array ([]): The effect runs only once, after the initial render.
Passing nothing: The effect runs after every render, including the initial render.


2. useMemo:

useMemo is a React Hook that memoizes the result of a computation.
It only recomputes the memoized value when one of the dependencies has changed.
Useful for optimizing performance by avoiding expensive calculations on every render.
Wrap the expensive computation inside useMemo and provide dependencies. The computation is re-evaluated only when the dependencies change.

function ExpensiveComponent({ a, b }) {
  const computeExpensiveValue = (a, b) => {
    // Expensive computation
    return a + b;
  };
  const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
  return <div>Computed Value: {memoizedValue}</div>;
}

3, useCallback:

useCallback returns a memoized version of the callback function.
Useful to prevent unnecessary re-creation of functions, especially when passing callbacks to child components that rely on reference equality to avoid re-renders.
Wrap the callback function inside useCallback and provide dependencies. The memoized callback is re-evaluated only when the dependencies change.

Note:
useCallback should be used with React.memo in child components to prevent unnecessary re-renders.
If we use useCallback but not React.memo, the child component will still re-render because the reference to the callback function changes on every render when parent component re-renders (all its children re-render).
If we use React.memo, but not useCallback, the child component will re-render because the parent component re-renders and passes a new prop (callback function) to the child component.

function ParentComponent() {
  const [count, setCount] = useState(0);
  const increment = useCallback(() => {
    setCount(prevCount => prevCount + 1);
  }, []);
  return (
    <div>
      <ChildComponent onClick={increment} />
      <p>Count: {count}</p>
    </div>
  );
}

const ChildComponent = React.memo(({ onClick }) => {
  console.log('Child rerendered');

  return <Button onClick={onClick}>Increment Count</Button>;
});


// Difference between useMemo and useCallback:

| Hook         | With Hook                                         | Without Hook                                          |
|--------------|---------------------------------------------------|------------------------------------------------------|
| `useMemo`    | Memoizes result of expensive computation.         | Recomputes value on every render, potentially slowing  down the component. |
| `useCallback`| Memoizes callback function to prevent re-creation.| Callback function is recreated on every render, potentially causing unnecessary re-renders of child components. |


4. useRef:
useRef is a built-in hook in React that allows you to create a reference to a DOM element or a mutable instance variable that persists for the lifetime of the component.
A mutable instance variable is a value that can be changed and persists for the lifetime of the component, but changing it does not cause the component to re-render.

const MyComponent = () => {
  const myRef = useRef(0); // This is a mutable instance variable

  const increment = () => {
    myRef.current = myRef.current + 1;
    // Even though myRef.current has changed, this will not cause a re-render
  };

  return <button onClick={increment}>Increment</button>;
};

function TextInputWithFocusButton() {
  const inputEl = useRef(null);
  const onButtonClick = () => {
    inputEl.current.focus();
  };
  return (
    <div>
      <input ref={inputEl} type="text" />
      <button onClick={onButtonClick}>Focus the input</button>
    </div>
  );
}


5. useReducer:

useReducer is a React Hook that is used for state management. It is an alternative to useState for more complex state logic.
It takes a reducer function and an initial state as arguments and returns the current state and a dispatch function.

const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    default:
      throw new Error();
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);
  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'increment' })}>Increment</button>
      <button onClick={() => dispatch({ type: 'decrement' })}>Decrement</button>
    </div>
  );
}


6. useContext:

The Context API in React provides a way to share values like state or functions between components without having to explicitly pass props through every level of the tree.
It is useful for managing global state, themes, or user settings across a React application.

export const AppContext = createContext();
export const AppContextProvider = ({ children }) => {
  const [selectedShades, setSelectedShades] = useState(JSON.parse(sessionStorage.getItem('selectedShades') ?? '[]'));
  useEffect(() => {
    sessionStorage.setItem('selectedShades', JSON.stringify(selectedShades));
  }, [selectedShades, selectedSizes]);

  const contextValue = {
    selectedShades,
    setSelectedShades
  };
  return <AppContext.Provider value={contextValue}>{children}</AppContext.Provider>;
};

//Wrap the components where you want to use the context with the AppContextProvider
<AppContextProvider>
  <App />
</AppContextProvider>

// Usage in a component
const { selectedShades, setSelectedShades } = useContext(AppContext);


7. useState:
Usestate is a React Hook that allows functional components to manage state. It returns a stateful value and a function to update it. The initial state is passed as an argument to useState.

const [count, setCount] = useState(0);

or passing a function to useState for custom initialization:
const [count, setCount] = useState(() => {
  const initialCount = 0;
  return initialCount;
});
*/

/*
Custom Hooks:
A custom hook is a JavaScript function that starts with "use" and allows you to reuse stateful logic across multiple components.

Example of a Custom Hook implementing local storage:

function useLocalStorage(key, initialValue) {
  const [state, setState] = useState(() => {
    const storedValue = localStorage.getItem(key);
    return storedValue ? JSON.parse(storedValue) : initialValue;
  });

  useEffect(() => {
    localStorage.setItem(key, JSON.stringify(state));
  }, [key, state]);

  return [state, setState];
}

Usage of the Custom Hook:
const [name, setName] = useLocalStorage('name', 'John Doe');


Example of a Custom Hook implementing fetching data:

function useFetch(url) {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(true);
    
    useEffect(() => {
        const fetchData = async () => {
        const response = await fetch(url);
        const result = await response.json();
        setData(result);
        setLoading(false);
        };
    
        fetchData();
    }, [url]);
    
    return { data, loading };
    }

Usage of the Custom Hook:
const { data, loading } = useFetch('https://api.example.com/data');

*/

//React Fiber:
/*
React Fiber is a complete rewrite of the React core algorithm, designed to improve performance and enable new features like async rendering and error boundaries.
It is a reimplementation of the React reconciliation algorithm, which is responsible for updating the virtual DOM and determining the minimal set of changes needed to update the actual DOM.
React Fiber allows for incremental rendering, which means that the work of rendering a component can be split into chunks and spread out over multiple frames, improving the responsiveness of the UI.
Fiber also enables the scheduling of updates, prioritizing high-priority updates like user interactions over less critical updates.
React Fiber is the foundation for features like Suspense, Concurrent Mode, and the new concurrent rendering model in React.

Key Features of React Fiber"

Incremental Rendering:
React Fiber allows React to break down the rendering work into smaller units, called fibers.
This enables React to pause and resume work, making it more responsive, especially during complex updates.

Prioritized Updates:
React Fiber introduces a priority system for updates, allowing more important updates (e.g., user interactions) to be handled before less critical ones (e.g., background data fetching).
This ensures a smoother user experience by prioritizing updates that affect the user interface.

Concurrency:
React Fiber supports concurrent rendering, which means it can work on multiple tasks at once and decide which updates to prioritize.
This makes React more efficient at handling large and complex applications.

Better Error Handling:
Fiber improves error handling by introducing more granular error boundaries.
Components can catch and handle errors in their rendering, preventing the entire application from crashing.

Portals:
React Fiber supports portals, allowing components to render children into a different part of the DOM hierarchy.
This is useful for implementing modals, tooltips, and other overlay components.
*/

// Error Boundaries:
/*
Error boundaries in React are components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of crashing the entire component tree. They are useful for improving the user experience and debugging.
Error boundaries are implemented using the lifecycle methods componentDidCatch and static getDerivedStateFromError in class components. As of now, error boundaries can only be implemented using class components, not function components.
While error boundaries themselves must be class components, you can still use function components within error boundaries. There’s currently no direct hook equivalent to error boundaries, but you can manage errors inside function components using useEffect and try/catch.

Note:
Error boundaries do not catch errors in event handlers (e.g., onClick) or during server-side rendering.
Error boundaries only catch errors in the components below them in the tree, not above.
They catch errors during rendering, in lifecycle methods, and in constructors of the class components.
Only errors that occur while rendering the component or its children will be caught in case of function components.
Error boundaries do not catch errors in asynchronous code (e.g., setTimeout or fetch) or in event listeners.


// Example of an Error Boundary class component:

import { Component } from 'react';
class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }
  static getDerivedStateFromError(error) {
    // Update state so the next render will show the fallback UI
    return { hasError: true };
  }
  componentDidCatch(error, errorInfo) {
    // You can also log the error to an error reporting service
    console.error("ErrorBoundary caught an error", error, errorInfo);
  }
  render() {
    if (this.state.hasError) {
      // You can render any custom fallback UI
      return <h1>Something went wrong.</h1>;
    }
    return this.props.children; 
  }
}

// Usage of the Error Boundary component:
function App() {
  return (
    <div>
      <ErrorBoundary>
        <MyComponent />
      </ErrorBoundary>
    </div>
  );
}

*/
